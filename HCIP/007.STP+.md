# STP

此前的STP章节中有提到，STP的BPDU类型有两种，由上向下用于选举根交换机以及确定每个交换机端口角色和状态的Configure BPDU、由下向上用于通知拓扑发生变更的TCN BPDU。TCN BPDU解决了MAC地址表的默认老化时间（300s）问题，二层数据转发依靠MAC地址表，即便通过STP解决了故障链路的问题，数据按照MAC地址表仍有可能会向故障Root Port转发导致通信失败

**网桥发送TCN BPDU的条件为**

- 有端口转变为Forwarding状态，且该网桥至少包含一个指定端口
- 有端口从Forwarding状态活Learning状态转变为Blocking状态

```Topology
    <SW1> 根桥
   /     \
<SW2>---<SW3>
```

以此拓扑示意图为例，假设SW2与根桥互联的Root Port故障，此时STP会恢复SW2的备用链路的通信，将SW2与SW3互联的链路重新选举为SW2的Root Port，那么此时SW2会发送TCN BPDU吗？由于此时SW2上没有指定端口，并且端口故障会回退到Disabled状态，因此SW2不会向上游发送TCP BPDU，反而是SW3是有可能发送TCN BPDU的。如果SW2与SW3互联的链路上，SW3的端口原本是阻塞端口，那么SW2重新选举Root Port后，SW3的阻塞端口会转变为Designated Port，并进入Forwarding状态。如果想要实现SW2向上游转发TCN BPDU，则在SW2的下游接上一个PC即可，一个PC则意味着一个指定端口

![TCA&TC置位的配置BPDU.png](https://www.z4a.net/images/2024/06/08/TCATCBPDU.png)

此前的STP章节中提到过BPDU标记字段有8个bit位，只不过STP仅使用首位和末位，MSTP是8位都使用；收到TCN类型的BPDU后，在标记字段中会标记TCA（Topology Change Acknowledgment）和TC（Topology Change）的值为1。STP的抓包数据中甚至都没有1~6置位的信息

# RSTP

STP协议虽然能够解决环路问题，但是由于网络拓扑收敛较慢，影响了用户通信质量，而且如果网络中的拓扑结构频繁变化，网络也会随之频繁失去连通性，从而导致用户通信频繁中断，这也是用户无法忍受的，由于STP的不足，IEEE于2001年发布的802.1w标准定义了RSTP。RSTP在STP基础上进行了诸多改进优化，使得协议更加清晰、规范，同时也实现了二层网络拓扑的快速收敛

## STP的五大问题

**一、设备开机运行STP初始化**

![STP五大问题其一](https://www.z4a.net/images/2024/06/08/STP.png)

由于STP的Forward Delay计时器，STP从初始状态到完全收敛至少需要30s

**二、直连链路故障**

![STP五大问题其二](https://www.z4a.net/images/2024/06/08/STP17e8540607a08b0e.png)

直连链路故障的场景对应的是SWC，SWC的Root Port故障后，由于Blocked Port一直从SWB的DP收到根桥的BPDU，因此SWC的Blocked Port转换为新的Root Port，经过2个Forward Delay超时后进入Forwarding状态

**三、非直连链路故障**

![STP五大问题其三](https://www.z4a.net/images/2024/06/08/STP2b620a78fef72f28.png)

非直连链路故障的场景对应的是SWB，SWB自身没有Blocked Port，也就意味着SWB不会从除Root Port以外的任何端口收到根桥的BPDU，那么当SWB的Root Port故障时，SWB不会立刻将Designated Port变更为Root Port，而是判断根桥故障，并认为自身就是新的根桥，向外发送自身的BPDU；SWC仍能正常收到根桥的BPDU，因此SWC对SWB的次优BPDU不做处理，直到STP的Max Age超时

**四、交换机连接用户终端**

![STP五大问题其四](https://www.z4a.net/images/2024/06/08/STP9f5eb80ad6c97c28.png)

交换机连接终端的链路进入转发都需要经过2次Forward Delay计时器，并且任何的变更（包括插拔网线）都有可能导致STP计算，影响到终端的连通性

**五、STP的拓扑变更机制**

![STP五大问题其五](https://www.z4a.net/images/2024/06/08/STP7a8248eb0506125c.png)

虽然通过TCN机制能够实现全网拓扑对齐，但TCN、TCA、TC的机制复杂，效率低下。在大二层环境下，由下游交换机逐层向上转发TCN报文、逐层向下转发TCA报文，根桥收到TCN报文后又向下游交换机转发TC报文，之后还需要等待老化时间

## RSTP

RSTP从STP发展而来，实现的基本思想一致，RSTP能够兼容STP运行，高版本的STP都能够兼容低版本的STP运行，包括MSTP也能够兼容STP运行，RSTP与STP的不同在于4点

- RSTP减少了端口状态
- RSTP增加了端口角色
- RSTP的BPDU格式及发送方式不同
- 当交换网络拓扑结构发生变化时，RSTP可以更快的恢复网络的连通性

### RSTP的变动

**基本抓包实验拓扑**

```Topology
    <SW1>
   /     \
<SW2>---<SW3>
```

```VRP
#----------------------------------SW1----------------------------------
system-view
sysname Switch_1
stp mode stp

#----------------------------------SW2----------------------------------
system-view
sysname Switch_2
stp mode stp

#----------------------------------SW3----------------------------------
system-view
sysname Switch_3
stp mode stp
```

修改STP模式后查看根桥属于哪个机器，修改SW1的优先级使其成为根桥，修改SW1优先级后可以频繁使用查看SW1的STP状态，很明显能观察到STP State由DISCARDING状态到LEARING、FORWADING状态的转变过程，非常直观的能感受到STP收敛速度之慢

```VRP
[Switch_1]stp priority 4096
[Switch_1]display stp brief
```

我的拓扑中SW2的另一个端口角色是阻塞端口，关闭SW2的Root Port后频繁查看SW2的STP状态可以观察到，即便拓扑中SW2就只有两个端口，关闭SW2的Root Port后SW2就只能选择阻塞端口成为新的Root Port，在这种情况下SW2的阻塞端口切换成Root Port仍需要经过2次Forward Delay计时器，理论上阻塞端口需要经过Listening、Learning、Forwarding三个状态，但eNSP上只能看到Discarding状态；恢复SW2的原Root Port观察STP状态，又要等待2次Forward Delay计时器，STP模式下任何的端口变更都需要经过至少30s的等待

```VRP
[Switch_2]interface g0/0/1
[Switch_2-GigabitEthernet0/0/1]shutdown
[Switch_2-GigabitEthernet0/0/1]display stp brief
[Switch_2-GigabitEthernet0/0/1]undo shutdown    #查看测试效果后重新开启端口
```

**RSTP将端口状态缩减为3个**

<table>
    <tr>
        <th>STP端口状态</th>
        <th>RSTP端口状态</th>
        <th>端口状态对应的行为</th>
    </tr>
    <tr>
        <td>Disabled</td>
        <td rowspan="3">Discarding</td>
        <td rowspan="3">不转发用户流量<br />不学习MAC地址</td>
    </tr>
    <tr>
        <td>Blocking</tr>
    </tr>
    <tr>
        <td>Listening</td>
    </tr>
    <tr>
        <td>Learning</td>
        <td>Learning</td>
        <td>不转发用户流量<br />学习MAC地址</td>
    </tr>
    <tr>
        <td>Forwarding</td>
        <td>Forwarding</td>
        <td>转发用户流量<br />学习MAC地址</td>
    </tr>
</table>

在eNSP模拟器上，即便运行STP协议也看不到5种端口状态，只能看到3种端口状态

**RSTP将端口角色增加到4个**

| 端口角色 | 说明 |
| :-- | :-- |
| Root Port<br />根端口 | 所在交换机上离根交换机最近的端口，处于转发状态 |
| Designated Port<br />指定端口 | 转发所连接的网段发往根交换机方向的数据<br />从根交换机方向发往所连接的网段的数据，处于转发状态 |
| Alternate Port<br />预备端口 | 根端口的备份，不处于转发状态 |
| Backup Port<br />备份端口 | 指定端口的备份，不处于转发状态 |

Alternate端口比较好理解，能够经常看到，但Backup端口不常见，Backup端口一般出现在两台交换机互联的链路中间穿插了集线器或分光器之类的设备的场景，一台交换机多条链路接在集线器上，与对端相连

```Topology
        <SW1>
       /     \
      /       \
     /         \
    /           \
 <SW2>--<hub>==<SW3>
```

在原有拓扑的SW2与SW3的互联链路中添加一台hub，SW3会根据指定端口的选举规则重新选举Designated Port，依次比较根路径开销、本端BID、本端PID，前两者都相同，最终比较PID，PID小的成为指定端口，反之称为Backup Port。在SW3上查看STP状态已经能观察到Backup Port，虽然显示Backup Port，但现在仍是运行的STP协议

```VRP
#----------------------------------SW1----------------------------------
[Switch_1]stp mode rstp

#----------------------------------SW2----------------------------------
[Switch_2]stp mode rstp

#----------------------------------SW3----------------------------------
[Switch_3]stp mode rstp
```

将所有交换机的STP版本切换为RSTP，测试SW2和SW3的端口状态切换。先观察SW2的STP状态确认Alternate Port处于Discarding状态，关闭SW2的Root Port可以看到SW2的Alternate Port立刻成为Root Port并处于Forwarding状态；同样的测试SW3的Backup Port，观察SW3的STP状态确认Designated Port和Backup Port所对应的端口号，关闭Designated Port后观察STP状态，理论上Backup Port虽然不是立马切换为Designated Port，但转换速度也应该较快，eNSP模拟器似乎仍需等待50s后才能切换好

```VRP
#----------------------------------SW2----------------------------------
[Switch_2]display stp brief 
 MSTID  Port                        Role  STP State     Protection
   0    GigabitEthernet0/0/1        ROOT  FORWARDING      NONE
   0    GigabitEthernet0/0/2        ALTE  DISCARDING      NONE
[Switch_2]interface g0/0/1
[Switch_2-GigabitEthernet0/0/1]shutdown
[Switch_2-GigabitEthernet0/0/1]display stp brief
[Switch_2-GigabitEthernet0/0/1]undo shutdown    #测试完成后启用端口
[Switch_2-GigabitEthernet0/0/1]display stp brief

#----------------------------------SW3----------------------------------
[Switch_3]dis stp brief 
 MSTID  Port                        Role  STP State     Protection
   0    GigabitEthernet0/0/1        ROOT  FORWARDING      NONE
   0    GigabitEthernet0/0/2        DESI  FORWARDING      NONE
   0    GigabitEthernet0/0/3        BACK  DISCARDING      NONE
[Switch_3]interface g0/0/2
[Switch_3-GigabitEthernet0/0/2]shutdown
[Switch_3-GigabitEthernet0/0/2]display stp brief
```

#### RSTP BPDU格式

相较STP不同之处有

- Protocol Version ID变为2
- BPDU Type变为2
- 使用了Flags字段的全部8个置位

在RSTP BPDU的Flags字段中，除了TC、TCA标志位以外，还包含有P/A标志位、端口状态标志位、端口角色标志位

![RSTP-BPDU的Flags](https://www.z4a.net/images/2024/06/09/RSTP-BPDUFlags.png)

![RSTP-BPDU的Flag端口角色组合](https://www.z4a.net/images/2024/06/09/RSTP-BPDUFlagsed1084bbbabacb87.png)

### RSTP针对STP五大问题的变更

**一、针对计时器问题的P/A机制**

![RSTP的P/A机制.png](https://www.z4a.net/images/2024/06/09/RSTPP-A.png)

在已经选举出根桥的场景下，根桥的端口应该都是指定端口（除非自己插自己），根桥会从Designated Port发送P置位的BPDU，此时根桥的BPDU中Flags的P置位值为1，为了防止环路，此时根桥的指定端口还处于Discarding状态；SWB从根桥收到P置位的BPDU后会开始同步，阻塞自身除边缘端口以外的其他端口，并从Root Port向根桥回复A置位的BPDU，根桥收到收到SWB的A置位BPDU后该端口立刻进入Forwarding状态。RSTP依靠P/A机制确认链路状态，无需依靠计时器来保障无环

```Topology
<hub>---<SW1>
  |          \
  |           \
  |            \
  |             \
 <SW2>--<hub>==<SW3>
```

为了方便抓包查看P/A机制，在SW1和SW2的互联链路中加入一个hub，SW1设置了STP的优先级，因此SW1会保持根桥身份，此时在SW2上抓包与SW1互联的端口，然后启停一下SW1上与SW2互联的端口，根据MAC地址的变化查看抓包信息

![RSTP的P/A机制](https://www.z4a.net/images/2024/06/09/P-ABPDU.png)

关闭根桥的端口之前会发现，从多个抓包信息中可以看到根桥正常的BPDU包中会一直保持发送A置位，但是P置位只有端口启停的瞬间会发送一个BPDU，且P置位的BPDU中根桥的Designated Port端口状态就是处于Discarding

关闭根桥端口后稍作等待会在抓包信息中看到SW2会向外发送P置位的BPDU，此时可能是由于hub的原因，SW2的端口角色并不会马上切换，而是等待一段时间后切换端口角色，并且端口角色的切换由原本的“Root Port+阻塞端口”变为“Designated Port+Root Port”，端口角色切换的同时，SW2不在向外发送P置位的BPDU，而是发送A置位的BPDU，再等待一段时间后发现SW2切换后的Designated Port的端口状态由Discarding变为Forwarding

![RSTP的P/A机制2](https://www.z4a.net/images/2024/06/09/RSTPP-A2.png)

交换机设备刚开机运行STP协议的情况下，都会认为自身就是根桥，因此都会向外发送P置位的BPDU，经过一次P置位的BPDU后就能够选举出根桥，下游交换机会向根桥转发A置位的BPDU，最后是非直连链路的转发

- RSTP选举原理和STP本质上相同：选举根交换机-选举非根交换机上的根端口-选举指定端口-选举预备端口和备份端口
- 但是RSTP在选举的过程中加入了“发起请求-回复同意”（P/A机制）这种确认机制，由于每个步骤有确认就不需要依赖计时器来保证网络拓扑无环才去转发，只需要考虑BPDU发送报文并计算无环拓扑的时间（一般都是秒级）

**二、直连链路根端口快速切换**



RSTP在非根交换机上选举完Root Port后还会选举Alternate Port，预备端口用于在根端口发生故障时切换成为新的根端口，这个切换动作是在交换机自身内部进行的，切换端口角色后直接进入Forwarding状态

**三、非直连链路根端口快速切换**



原本STP的Root Port故障后，SWB认为自身就是根桥，并会向邻居发送自身BPDU，邻居对SWB的BPDU包不做处理，等待BPDU老化计时器超时后邻居才会重新开始选举端口角色，RSTP下邻居收到SWB的BPDU包发现是次优BPDU时，会马上发送本地最优的BPDU给SWB，并完成自身的端口角色转换

**四、边缘端口机制**



