---------

## 端口隔离

**端口隔离：实现<font color="red">同一VLAN内端口之间的隔离</font>**

- 交换机端口之间的一种访问控制安全机制

- 配置端口隔离后，无论是哪个VLAN，都不能互相通信

  | 命令                           | 说明                                                     |
  | ------------------------------ | -------------------------------------------------------- |
  | port-isolate enable [group 5]  | 开启端口隔离功能，默认加入Group 1                        |
  | [SW-G0/0/2]am isolate G0/0/1   | 配置从G0/0/2到G0/0/1的单向隔离（禁止从G0/0/2访问G0/0/1） |
  | port-isolate mode all          | 端口隔离模式更变为二层、三层都隔离，默认仅隔离二层       |
  | display port-isolate group all | 查看隔离端口组信息                                       |

  Group就是一个隔离组，加入该隔离组的端口之间不允许访问；端口隔离模式可用于应对ARP代理，二层的端口隔离能够被ARP代理恢复正常通信，三层端口隔离可以突破ARP代理

在某些非网管交换机上会有三种网络可选模式：网络克隆、标准交换、VLAN隔离，标准交换就是正常的二层交换，网络克隆是对类似PXE批处理应用的一种优化，VLAN隔离则是实现了端口隔离的功能。VLAN隔离一般是除了交换机的最后两个端口作为Uplink口以外，其他所有端口处于同一隔离组，实现端口隔离功能，各厂家的交换机可能有所不同，以设备参数为准

```Topology
              <SW1>
             /  |  \
     G0/0/1/    |    \ G0/0/3
        <PC1> <PC2> <PC3>
              G0/0/2  
```

```VRP
<Huawei>system-view
[Huawei]sysname Switch_1
[Switch_1]interface g0/0/1
[Switch_1-GigabitEthernet0/0/1]port-isolate enable group 1
[Switch_1-GigabitEthernet0/0/1]interface g0/0/2
[Switch_1-GigabitEthernet0/0/2]undo port-isolate enable group 2
[Switch_1-GigabitEthernet0/0/2]interface g0/0/3
[Switch_1-GigabitEthernet0/0/3]am isolate g0/0/1
```

配置单向隔离后，在对应的两个端口抓包，在G0/0/1端口抓包观察，从PC1到PC3在正常的发包，但没有收到PC3的回包；在G0/0/3端口抓包观察，PC3能够收到PC1的包，且给PC1也有回包。因此，PC3给PC1的回包实际上是在数据到达交换机的G0/0/3口时没有转发

通过两个端口下的主机ping回显信息也能看出问题，PC1的ping包回显是“目标主机不可达”，说明PC1通过ARP请求没有获取到PC3的MAC，这是因为G0/0/3端口没有将主机的ARP回复转发到G0/0/1，而PC3的ping包回显是“请求超时”，PC3本身是有PC1的ARP缓存的，这个缓存理论上应该是在PC1发起ARP请求时，PC1的ARP请求包中存在PC1自身的MAC，PC3收到PC1的ARP请求后将PC1的MAC写入自身缓存

## ARP代理

**Proxy ARP：如果ARP请求是从一个网络的主机发往同一网段<font color="red">却不在</font>同一物理网络上的另一台主机（被隔离），那么连接它们的具有代理ARP功能的设备就可以回答该请求，这个过程被称作代理ARP**

- 屏蔽了分离的物理网络，使用户使用起来，好像在同一个物理网络上
- 分为普通代理ARP和本地代理ARP

| 命令                                  | 说明                                                  |
| ------------------------------------- | ----------------------------------------------------- |
| arp-proxy enable                      | 启用ARP代理。一般用于路由器，因为路由器没有VLAN的概念 |
| arp-proxy inner-sub-vlan-proxy enable | 在相同VLAN内启用ARP代理                               |
| arp-proxy inter-sub-vlan-proxy enable | 在不同VLAN间启用ARP代理                               |

注：ARP代理功能必须在三层接口下启用

<table>
    <tr>
    	<td><font color="red">普通代理ARP</font></td>
        <td>想要互通的主机分别连接到设备的不同三层接口上，且这些主机不再同一广播域中<br /><img src="https://www.z4a.net/images/2024/06/06/ARP.png" alt="普通代理ARP"/></td>
    </tr>
    <tr>
    	<td><font color="red">本地代理ARP</font></td>
        <td>想要互通的主机连接到设备的同一个三层接口上，且这些主机不在同一个广播域中<br /><img src="https://www.z4a.net/images/2024/06/06/ARPdeda78645d1b27a9.png" alt="本地代理ARP"/></td>
    </tr>
</table>

```VRP
[Switch_1]interface vlanif 1
[Switch_1-Vlanif1]ip address 192.168.0.254 24
[Switch_1-Vlanif1]arp-proxy inner-sub-vlan-proxy enable
```

在交换机上新建一个Vlanif 1接口并配置IP，默认情况下三个PC都处于VLAN 1下，此时再通过PC1向PC3发起ping包是通的，查看PC1的ARP缓存则能看到，PC3的IP和Switch_1的IP所对应的MAC地址是相同的

```VRP
PC1>arp -a 

Internet Address    Physical Address    Type
192.168.0.254       4C-1F-CC-73-05-A3   dynamic
192.168.0.3         4C-1F-CC-73-05-A3   dynamic
```

PC1发起ping包之前必须通过ARP请求获取到目标MAC，此前已经分析过，虽然PC1的ARP请求能到PC3，但PC3的ARP回复包到不了PC1，因此PC1还是没能获取到PC3的MAC。PC1的ARP请求除了能到PC3，它还能到交换机的Vlanif 1接口，此时属于同一广播域内通信，不涉及到网关，因此Vlanif 1的IP对于此时PC1到PC3的通信没有作用，关键在于Vlanif 1接口下开启了ARP代理功能

交换机上开启ARP代理功能后，PC1的ARP请求到达交换机后，交换机会根据ARP请求包中的目标IP（PC3的IP），查询自身是否可达PC3，如果交换机自身可达PC3则将自身的MAC回复给PC1，这也是为什么在PC1上查看ARP缓存表时，交换机Vlanif 1的IP和PC3的IP对应的MAC地址是同一个，实际上这个MAC地址就是交换机的MAC

交换机在开启代理ARP功能后转发数据包时，会对数据包重新进行封装，将数据包中的源MAC封装为自身MAC，因此查看PC1与PC2互通后的ARP缓存，两者各自IP对应的MAC都是交换机的MAC；查看PC1与PC3互通后的ARP缓存，PC1的ARP缓存对应的MAC是交换机的MAC，PC3的缓存是PC1的MAC

> **关于出接口和下一跳问题**

```Topology
<R1>------------<R2>---2.2.2.2
```

在HCIA课程中有一个静态路由的实验提到过，在MA网络中配置路由必须指定下一跳地址，如果是串口则可以使用下一跳地址或出接口

```VRP
ip route-static 2.2.2.2 32 12.0.0.2
ip route-static 2.2.2.2 32 g0/0/0
```

静态路由写出站接口和写下一跳是不一样的，其根本原因还是在于ARP。在以太网环境中，写入路由时指定下一跳IP，发起ping包通信正常，这是因为R1在封装数据包时，目标IP是下一跳地址`12.0.0.2`，R1查找自身路由表发现是直连网段，R1会向R2发起ARP请求，获取`12.0.0.2`的MAC地址，然后R1再发起ping包，从抓包中也能看到ping包的目标IP是`2.2.2.2`，但目标MAC却是`12.0.0.2`的MAC地址，也只能是`12.0.0.2`的MAC地址，否则R2不会收包

如果在以太网环境中，写入路由时指定出接口，发起ping包通信失败，此时查看R1的路由表会发现去往`2.2.2.2`的下一跳地址是该出接口的IP，例如，R1的G0/0/0口配置的IP是`12.0.0.1`，则指定出接口时下一跳地址指向`12.0.0.1`，也就是说下一跳是R1自己。那么此时R1在发起ping包之前，首先要通过ARP请求获取到目标MAC，此时R1发起的ARP请求会直接请求`2.2.2.2`的MAC，而`2.2.2.2`跟R1根本不在同一广播域，因此R1自身是请求不到`2.2.2.2`的MAC的，通信失败

此时，如果在R2的G0/0/0口开启代理ARP则通信恢复正常，因为R2的G0/0/0口能够收到R1的ARP请求，且R2本身也可达`2.2.2.2`，因此R2会将自身G0/0/0端口的MAC地址回复给R1

串口下指定下一跳或出接口都行，是因为串口使用PPP协议或HDLC协议封装二层，它们没有MAC地址，因此也没有ARP，它只看IP地址