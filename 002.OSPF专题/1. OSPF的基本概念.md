# 路由协议的分类

```
                                                                             路由
                                                                              |
                                                ------------------------------------------------------------
                                                |                                                          |
                                             非直连路由                                                   直连路由
                                                |
                                   ----------------------------------------------------------
                                   |                                                        |
                              动态路由协议                                                 静态路由
                                   |
                      -------------------------------------------------------
                      |                                                     |             
                 内部网关协议IGP          <---（按AS区分）--->          外部网关协议EGP
                      |                                                     |
              ------------------------------                               BGP
              |                            |
距离矢量协议（Distance Vecter)      链路状态协议（Link-State）
              |                            |
          --------                      --------
          |      |                      |      |
         RIP   EIGRP                   OSPF  IS-IS
```

静态路由特点：

1. 简单、高效、稳定、开销小，适合小规模组网
2. 中大规模组网中配置量较大
3. 强依赖管理员的经验和技术水平，容易产生环路或次优路径
4. 无法自动适应拓扑变更

动态路由特点：

1. 需要额外占用设备、网络资源去建立、维护路由器之间的邻居关系和路由信息
2. 自动计算路由构建路由表，根据路由表执行数据转发
3. 自动适应拓扑变更

静态路由完全依赖管理员手动配置和维护，复杂的组网下使用静态路由容易产生环路或次优路由。静态路由配置简单、开销小，可以实现负载均衡和路由备份，适用于小规模组网场景，大规模组网中使用静态路由时配置和维护的成本都比较高，因此大规模组网中往往采用动、静态路由结合的方式部署

# OSPF基本概念

OSPF（Open Shortest Path First）开放式最短路径优先协议是IETF定义的一种基于链路状态的IGP协议，OSPF直接工作于网络层的IP协议中，IP协议号为89。这意味着OSPF只支持IP协议，这对于现在的网络环境而言也算不上什么缺陷

**OSPF概述**

- 大中型网络使用最广泛的基于链路状态的IGP协议
- 无类路由协议
- 使用组播224.0.0.5和224.0.0.6
- 使用开销（OSPF的Cost，根据接口带宽来计算）作为度量值，收敛速度快
- 采用SPF算法可以有效避免环路
- 触发式更新，一旦路由状态产生变化立即触发更新；OSPF也具备周期性的更新，以较低的频率（每30分钟）发送定期更新，被称为链路状态泛洪
- 区域的设计使OSPF能够支持更大规模的网络
- 通过LSA的形式发布路由
- 不支持自动汇总，支持手动汇总
- 基于IP协议，使用IP协议号89

OSPF存在3个版本，OSPFv1是早期的实验版本、OSPFv2基于IPv4、OSPFv3基于IPv6。OSPF协议使用SPF算法计算路由，最早期使用SPF算法的是IS-IS协议，但由于IS-IS基于OSI协议栈研发，因此IETF取IS-IS协议的SPF算法，基于TCP/IP协议栈开发了OSPF协议，IS-IS后续也推出了集成IS-IS，集成IS-IS既支持OSI协议栈也支持TCP/IP协议栈

**链路状态路由协议**

1. 路由器会将自身所有链路状态信息汇总泛洪到网络中
2. 收集其他路由器泛洪的链路信息，并写入自身链路状态数据库（LSDB）
3. 路由器根据SPF算法以自身为根节点计算去往任意网段的最短路径树
4. 将通过SPF算法计算出的最短路径写入路由表

链路状态信息主要包含端口IP及掩码、链路带宽、链路上的邻居等信息，在OSPF协议中，LSA（Link-State Advertisement，链路状态通告）包含了链路状态信息，泛洪链路状态信息通过泛洪LSA实现，同时LSA也是LSDB的最小组成单位。SPF算法以自身为根节点，也就是说计算最短路径的时候会使用路由器自身去往目标网络的出接口的开销值；通信是一个双向的过程，对于本端路由器而言开销值最小的出接口可能是A链路，但对于对端路由器而言开销值最小的出接口也可能是B链路，因此OSPF路由器之间收发数据并不一定在同一条链路上，取决于两端路由器的SPF算法计算出的最短路径

**OSPF的3张表**

- Neighbor table：邻居表/邻接表；OSPF的邻居状态分为2种：邻居关系、邻接关系，邻居关系表示物理链路相连，但双方处于初始化状态无法交换OSPF信息。但对于这张Neighbor table而言无需区分的如此明细，既可以称为邻居表也可以称为邻接表
- Topology table：链路状态数据库表（LSDB）
- Routing table：路由表

相比较Distance Vecter，Link-State能够识别更多的路由信息。Distance Vecter只是传递路由表，每个路由器的状态类似道听途说；Link-State需要实现LSDB的同步，而LSDB中包含了整个网络中详细的链路状态信息，对整个网络的认知更加全面，因此Link-State倾向于做出更精确、更优的选路。每一个动态路由协议都会有自身的独立的数据库

## OSPF区域设计

为了适应大型网络，OSPF能在AS内划分多个区域（Area），区域以设备端口为单位进行划分，一个设备端口只能属于一个区域，因此一台设备可以属于一个或多个区域，每台OSPF设备只维护所在区域的LSDB

**OSPF区域特征**

- 最小化LSDB
- 将拓扑变化的影响局限在一个区域内
- 明细LSA泛洪会停止在区域边界
- 分层化的网络规划设计

因为每台OSPF设备会维护所在区域的LSDB，如果所有OSPF设备处于同一区域，那么每台OSPF设备的LSDB会变得异常庞大，区域设计的优势在于减小了OSPF设备需要维护的LSDB规模，间接性减小了OSPF设备的路由表条目、内存、CPU消耗，同时区域的拓扑变化也仅影响本区域内部

```
              OSPF区域设计
                   |
   ---------------------------------
   |                               |
Area 0                         非Area 0
                                   |
                      ---------------------------
                      |                         |
                   常规区域                   特殊区域
                                                |
                                    -------------------------
                                    |       |       |       |
                                   Stub   T-Stub   NSSA   T-NSSA
```

- Area 0：骨干区域，也称为传输区域，负责在不同非骨干区域之间分发路由信息
- 非Area 0：非骨干区域，所有非骨干区域必须与骨干区域直接相连，这是为了防止区域间形成路由环路
  - 特殊区域：减少特殊区域的LSA通告；由于OSPF协议主要面对于企业网，而企业网的特点之一就是设备的性能参差不齐，将性能低下的设备集中放置在特殊区域中，减少对该区域的LSA通告数量

> **注意**
> 
> 任何两个非骨干区域之间的互相通信都必须经过Area 0，且只会经过Area 0一次

**OSPF路由器的分类**

OSPF路由器根据处于区域的不同位置分为了4种路由器类型；一台路由器也可以同时属于多种类型

- IR：Internal Router，内部路由器，所有的接口都属于同一区域
- BR：Backbone Router，骨干路由器，至少有一个接口属于骨干区域
- ABR：Area Border Router，区域边界路由器，连接一个或者多个区域到骨干区域，至少有一个接口属于骨干区域
- ASBR：Autonomous System Border Router，自治系统边界路由器，把从其他路由协议学习到的路由以引入的方式到OSPF进程中

**区域ID**

区域ID（Area ID）：可以表示成一个十进制的数字，例如1；也可以表示成一个IP，例如0.0.0.1。配置OSPF协议时，在OSPF协议下宣告网络之前必须指定一个Area ID

### OSPF的邻居类型

二层链路是以太网多路访问（MA）网络时，如果设备之间两两建立邻居关系，那么参与OSPF网络的接口数量越多，OSPF的邻居关系数量会呈倍数增长，复杂的邻居关系会占用路由器本身的性能与网络带宽。OSPF最终的目的是为了同步LSDB，而不是为了建立邻居关系，因此为了减少OSPF数据包的交换次数，产生了DR（Designated Router）与BDR（Backup Designated Router）的选举，DR和BDR的选举能够一定程度上减少邻居关系的数量

DR的选举是基于链路端口的，每台路由器的某个端口所属的主干链路上需要选举出一个DR，这条链路上可以存在多台设备互联，一台路由器存在多个接口，每个接口所属的链路上都可以进行选举DR，所以DR并不指代某一设备，而是指该主干链路中的某台设备的某个接口。MA网络中某些场景下可以不选举BDR，但DR是必须选举的

| 术语 | 备注 |
| :-: | :-- |
| DR | Designated Router，指定路由器，MA网络中的主路由器 |
| BDR | Backup Designated Router，备用DR，DR宕机时BDR顶替成为DR |
| DROthers | 无身份的路由器 |
| 三者关系 | DR、BDR、DROthers三者之间都保持邻接关系（Full）<br />DROthers之间保持邻居关系（Two-Way） |
| 组播地址 | 224.0.0.5 向所有OSPF路由器发送<br />224.0.0.6 向DR和BDR发送链路状态更新 |
| 选举规则 | 1、比较Hello报文中携带的优先级<br />2、优先级一致时比较RID，越大越优先 |

> **Router Priority（优先级）**
>
> 在OSPF网络中用于选举DR和BDR
> - 优先级范围0~255，默认是1
> - 优先级最高的被选举为DR，优先级次高的被选举为BDR
> - 优先级为0的不参与选举

DR和BDR的选举具有非抢占性，除非DR和BDR都失效或重启OSPF进程；DROthers感知到拓扑变更后会向组播地址`224.0.0.6`发送LSU，DR、BDR会监听`224.0.0.6`这一组播地址，收到DROthers的LSU后DR会向`224.0.0.5`这一组播地址发送更新以通知其他DROthers，所有的OSPF路由器都会监听`224.0.0.5`组播地址，都会收到DR泛洪的LSU

*二层链路是P2P网络时，运行OSPF协议建立邻居关系无需选举DR或BDR，P2P网络的OSPF设备就是两两之间建立邻居关系*；DR与BDR的选举根据不同二层网络类型产生变化，只有MA网络才会选举DR和BDR，但*ExStart状态下的主从关系是无论何种二层网络类型都必须选举的*；部分场景下也会刻意将OSPF接口的网络类型修改为P2P类型，这样可以加快OSPF的收敛速度，因为P2P不需要选举DR、BDR，例如确保两台设备的以太网接口直接互联，中间没有其他二层交换机时，就可以将OSPF端口手动修改为P2P类型

**DR与BDR的选举**

1. 设备运行OSPF进程的初始状态，向外发送hello包，因为无法确认网络中是否存在DR/BDR，此时DR/BDR均为0.0.0.0
2. wait=dead=40s，期间监听DR/BDR的消息。如果网络中有DR/BDR，则自身成为DROther，接收并与DR同步LSDB，与DR/BDR形成邻接关系
3. 如果网络中没有DR/BDR，等待40s到期
4. 设备开始比较Priority/Router ID选举BDR，由于网络中没有DR，因此胜出的BDR转为DR
5. BDR转为DR后，其他设备再选举BDR

DR与BDR的选举实际上跟设备的配置顺序也有一定关系，最先配置的设备，最先开始计算wait时间，自然会最先超时，此时网络中没有其他设备与自身竞争，自然成为DR

### LSA的新旧关系

1. 序列号值越高代表该LSA越新
2. 序列号相同的情况下，校验和越大的LSA越新；LSA报文的头部信息中包含有链路状态校验和字段
3. 序列号和校验和相同的情况下比较老化时间；老化时间为3600s的LSA被无条件选中，老化时间不为3600s时比较两条LSA的时间差值，如果差值大于15min则老化时间较小的更新，如果差值小于15min则认为两条LSA相同

![LSA的更新规则](file:///${DB}/image/HCIP/LSA%E7%9A%84%E6%9B%B4%E6%96%B0%E8%A7%84%E5%88%99.png)

1. OSPF路由器收到LSU包后首先会检索自身LSDB，判断LSU包内的LSA是否已存在自身LSDB中，如果不存在则在LSDB中添加新记录
2. 如果自身LSDB已存在该LSA，则会判断两者序列号是否相同，如果序列号相同则丢弃LSU中的LSA
3. 如果LSU包中的LSA序列号更高，则更新自身LSDB
4. 如果LSU包中的LSA序列号更低，则将自身LSDB中更新的LSA信息，通过LSU发送到源路由器

**LSDB的同步**

LSDB的同步本质上是LSA的更新，而LSA的更新规则重点关注其序列号和老化时间。LSDB中每条LSA都有自己的序列号，正常情况下序列号的值会随着时间的推移而递增

- 序列号：是一个4字节的数字，与IP地址一样长，以16进制显示。序列号的值从`0x80000001`开始、到`0x7FFFFFFF`结束，从`0x80000001`开始累加后最终会累加到全F，再加1就要进位了，但序列号没有进位，所以到全F再加1又会从0开始累加，直到0x7FFFFFFF
- 老化时间：OSPF每次LSA更新都会导致序列号的值累加1，包括触发更新和周期性更新（每30分钟泛洪一次LSA），序列号值越高代表该LSA越新
- LSA更新机制：当一条LSA序列号为`0x7FFFFFFF`时，始发路由器会将该LSA的老化时间设置为3600s，其他设备收到该LSA后，因为序列号最大会无条件接受该LSA，此时又因为老化时间参数会删除该LSA。此时始发路由器会重新生成并发送序列号为`0x80000001`的全新LSA信息，实现序列号的刷新机制，因此最终序列号的值还是会返回到`0x80000001`

> 扩展
>
> `0x`开头表示十六进制数，且该数值有符号（分正负），带符号的数值的第一位数字表示符号位，`0x80000001`的第一位8转变为二进制表示`1000`，第一位为1表示负数

**LSA的老化时间**

- LS Age单位是秒，随时间而增长，越小代表该LSA越新
- 一条LSA在向外泛洪之前，LS Age的值需要增加InfTransDelay，该值可以在端口上设置，缺省为1秒，表示在链路上传输的延迟
- 如果一条LSA的LS Age达到了LSRefreshTime（30分钟），重新生成该LSA。重新生成LSA意味着序列号会增加，同时LS Age归零重新开始计算
- 如果一条LSA的LS Age达到了MaxAge（1小时） ，这条LSA会被删除。正常情况下LS Age是不会达到MaxAge的，因为达到LSRefreshTime时就会重新生成LSA，但如果路由器希望从网络中删除一条自己此前生成的LSA，则重新生成该条LSA的一个实例，将LS Age设置为MaxAge即可
- 如果路由器收到一条LS Age设置为MaxAge的LSA，则从LSDB中删除此LSA

在配置命令中，undo一下某一条OSPF的宣告路由，从抓包信息中就能够看到LSU包内的LSA，LS Age时间设置为了3600s，表示删除此路由

## OSPF的包类型

|                类型                 | 作用                                                         |
| :--------------------------------: | :----------------------------------------------------------- |
|               Hello                  | 建立并维护邻居关系；<br />1. 在OSPF刚刚启动的状态下，向外发送HELLO包寻找邻居；<br />2. 在邻居关系稳定后，每隔一段固定的时间向邻居发送HELLO，用来维持邻居关系<br />3. Hello间隔时间不同的ospf路由器之间无法建立邻居关系； |
|    Database Description（DBD）     | LSDB的摘要信息，仅包含LSA头部，用于路由器之间相互交换DBD获取对方LSDB中的LSA；<br />OSPF中不是通过交换路由表学习路由，是通过交换LSDB学习路由 |
|     Link-State Request（LSR）      | 请求LSA；<br />交换DBD报文收集双方LSDB中的差异后，请求对方LSDB中有而自身LSDB没有的LSA |
|      Link-State Update（LSU）      | 发送完整的LSA；<br />向邻居发送LSA |
| Link-State Acknowledgment（LSACK） | 对LSU报文的确认 |

在OSPF邻居建立完成后基本上就不会再产生DBD包和LSR包了，除非通过机制触发。如果某个路由器上的路由产生了新的变化，该路由器会主动向外发送LSU包，邻居路由器收到更新的LSA信息后也会给该路由器回复LSACK包，LSU包中更新的LSA会含有一个字段Sequence Number，这个字段就是序列号，用于标识LSA信息的新旧程度

### Router ID

运行OSPF协议前必须选取一个Router ID，可以手动配置也可以自动生成，手动配置Router ID的情况下，Router ID的地址跟路由器上任何一个端口的IP地址都没有必然的联系。Router ID用于在自治系统中唯一标识一台OSPF路由器，且在同一OSPF区域中Router ID不能重复，Router ID以32位整数的方式呈现，类似IP地址。

Router ID的选举优先级：

1. 手动配置
2. 活动的环回端口上，选举最大的IP地址作为Router ID
3. 活动的物理端口上，选举最大的IP地址作为Router ID

Router ID的选举具有非抢占性，当设备上的Router ID已经选举完成后，即便后续产生了更大的端口IP、或手动修改Router ID，也需要重启OSPF进程才会生效，重启OSPF进程意味着设备会删除LSDB、邻居关系等信息，需要重新获取。Router ID为0.0.0.0时是特殊情况，Router ID为0时不能成为DR或BDR；当路由器没有自己的Router ID时，即便向外宣告OSPF网段也不会产生任何信息

### 路由的优先级和度量值

路由协议的优先级用于比较一台设备上，通过不同的路由协议到达相同的目标网络的优先级，优先级的值越低，则路由协议越优先。例如设备RTA上能够同时通过RIP和OSPF到达目标网络1.1.1.0/24，此时根据路由协议的优先级比较，RTA会选择OSPF协议到达目标网络

路由的度量值用于比较一台设备上，通过同一路由协议到达同一目标网络的不同路径的优先级，度量值越低，则路径越优先。例如设备RTA通过OSPF协议学习到两条链路去往RTB，一条链路的Cost值为20、另一条链路Cost值为10，优先选择Cost值为10的链路到达目标网络；查看OSPF进程下的端口信息可以看到端口的开销值，每一个运行OSPF的端口上都维护着一个端口Cost，`Cost=10^8(bps)/BandWidth`

不同路由协议的优先级（Preference）是固定的，但Cost根据不同的协议有不同的算法，两者都可以调整

| 路由协议 | Direct | OSPF | IS-IS | Static | RIP | OSPF_ASE | OSPF_NSSA | IBGP | EBGP |
| :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
| 管理距离 | 0 | 10 | 15 | 60 | 100 | 150 | 150 | 255 | 255 |

## OSPF建立邻居的过程

![OSPF状态机制](file:///${DB}/image/HCIA/OSPF%E7%8A%B6%E6%80%81%E6%9C%BA%E5%88%B6.png)

<table>
    <tr>
        <th>状态</th>
        <th>说明</th>
    </tr>
    <tr>
        <td>Down（失效状态）</td>
        <td>ospf关闭状态，没有收到hello包，在Down状态下路由器会发出第一个hello包；执行OSPF重置后也会重新恢复为DOWN状态</td>
    </tr>
    <tr>
        <td>Init（初始状态）</td>
        <td>Init是一个one way状态，向外收发hello包寻找邻居，但没有在对方的hello包的邻居列表中看到自己；路由器收到一个hello包，且在该hello包的邻居列表没有自身的Router ID，则将自己和邻居的关系转变为Init状态</td>
    </tr>
    <tr>
        <td>Two-Way（双向通讯状态）</td>
        <td>在收到的hello包的邻居列表中看到自身的Router ID，双向会话建立，形成邻居关系；在MA网络中，Two-Way状态将开始选举DR/BDR，若P2P网络则跳过选举</td>
    </tr>
    <tr>
        <td colspan="2">-------------------------邻居发现阶段-------------------------</td>
    </tr>
    <tr>
        <td>ExStart（交换初始状态）</td>
        <td>ExStart是FirstDBD，决定信息交换时路由器的主从关系，Router ID大的为master；在相互交换DBD包的过程中，双方互相发送的第一个DBD包是空包，此两个包是为了选举出master，在ospf数据包报头中有包含Router ID的字段；思科设备缺省情况下在此阶段会检查MTU，如果MTU不一致则卡在ExStart状态</td>
    </tr>
    <tr>
        <td>ExChange（交换状态）</td>
        <td>向邻居发送完整的DBD数据包，DBD包只携带LSA的头部简要信息</td>
    </tr>
    <tr>
        <td colspan="2">-------------------------数据库开始同步-------------------------</td>
    </tr>
    <tr>
        <td>Loading（加载状态）</td>
        <td>LSR和LSU交换；收到邻居DBD包后，将对方的DBD包和自己的LSDB做对比，找出自己LSDB没有的LSA，相互发送LSR，LSU，LSACK</td>
    </tr>
    <tr>
        <td>Full（完全邻接状态）</td>
        <td>LSDB同步，相互发送HELLO包形成邻接关系</td>
    </tr>
    <tr>
        <td colspan="2">-------------------------LSDB同步完成-------------------------</td>
    </tr>
</table>

只有Two-Way和Full是稳定状态；OSPF的7种状态下存在2种关系，邻居关系和邻接关系，邻居关系不一定是邻接关系，邻接关系一定是邻居关系；在Two-Way状态或在其前都处于邻居状态，Two-Way后处于邻接状态

OSPF建立邻居的7种状态报文之间没有特别明显的界限，例如在ExStart、ExChange状态下，并不是一定要等待所有DBD报文交换完成之后，双方才进入Loading状态开始发起LSR、LSU，可能在刚开始交换DBD报文的过程中就已经开始发起LSR、LSU了，因为DBD报文中已经包含了LSA的头部信息

### ExStart的主从选举

DBD包的传输与TCP三次握手不同，DBD包的传输没有三次握手，但它也需要确保对端能够收到自身的DBD包，因此产生了ExStart的主从选举

DBD包的传输通过隐式确认的方式进行，FirstDBD包中含有四个字段，每个路由器在初始状态下向外发送DBD包时都认为自身是master，经过FirstDBD包选举出master后，双方传输的第二个DBD包就不再是空包了，携带有LSA头部信息，但是双方第二个DBD包乃至后续所有的DBD包中，DD Sequence都会变更为master的DD Sequence值，同时从节点的Master置位也不再为1，master收到从节点的DBD包后，查看DD Sequence值就可以确认对端已经收到了自身的DBD包

master的作用只是为了控制DD Sequence值的同步，Router ID大的成为master，只有master可以修改DD Sequence值，并且master修改DD Sequence值后，从节点的DBD包也会同步修改master设置的DD Sequence值

| 字段 | 说明 |
| :-- | :-- |
| Init | 是否为第一个包，值为1表示true |
| More | 后续是否还有更多的包，值为1表示true |
| Master | 自身路由器是否为Master，值为1表示true |
| DD Sequence | 序列号 |

## OSPF建立邻居的条件

| 条件 | 说明 |
| :-- | :-- |
| Area ID | 两端设备端口宣告的Area ID必须一致 |
| hello | 两端设备端口宣告的hello timer必须一致 |
| dead intervals | 两端设备端口宣告的dead intervals必须一致 |
| Authentication | 两端设备端口配置的认证信息必须一致 |
| Mask | MA网络要求两端设备端口的掩码必须一致 |
| MTU | 两端设备端口配置的MTU必须一致 |
| 区域类型 | 区域内设备的区域类型必须一致 |
| Router ID | 不同设备的Router ID必须唯一 |

ospf进程号仅本地有效，不会影响ospf建立邻居关系；dead intervals的值缺省情况下是hello timer的4倍，也可以单独手动设置；Mask只要求在MA网络中两端掩码必须一致，对P2P网络无要求

OSPF在建立邻居的过程中转发FirstDBD包的时候，在FirstDBD包中带有Interface MTU字段，华为设备缺省情况下的Interface MTU值置位成0，它并不是设备端口真实的MTU值，因此在华为设备之间建立OSPF邻居时并不检测MTU值。MTU的检测需要注意的是两端设备属于不同厂商的场景，由于OSPF属于公有协议，不同厂商对于MTU值检测的方式不同，例如cisco设备缺省检测MTU，不同厂商设备建立OSPF邻居时可能会因为MTU值不同导致无法建立邻居。由于使用DBD包检测MTU值，因此如果MTU值检测未通同，OSPF建立邻居会卡在ExStart、ExChange状态

### OSPF的网络类型

- *OSPF对于任何一种二层链路链路类型，缺省都会以一个三层的OSPF网络类型与之相适应*
- *根据拓扑和需求的变化，OSPF可以手工修改接口的网络类型，来更好的适应二层链路拓扑*

| OSPF网络类型 | 二层链路类型 | Hello/Dead | DR/BDR | 手动邻居 | /32位路由 |
| :-- | :-- | :-: | :-: | :-: | :-: |
| P2P（组播交互） | HDLC、PPP、FR点对点子接口 | 10/40 | NO | NO | NO |
| Broadcast（组播交互） | 以太网、令牌环网、FDDI | 10/40 | Yes | NO | NO |
| NBMA（单播交互） | 帧中继 | 30/120 | Yes | Yes | NO |
| P2MP（组播交互） | Hub-spoke（点到多点模型） | 30/120 | NO | NO | Yes |

在OSPF的P2P网络类型下，OSPF不会主动产生`/32`位的路由并宣告给邻居，但PPP二层链路类型会自动产生对端端口`/32`位的路由。在PPP链路下建立OSPF邻居后，能在路由表中看到对端端口的`/32`位路由，但观察该路由的协议类型是`Direct`；另外就是loopback端口的路由，缺省情况下通过OSPF学习到的loopback端口的路由，无论该loopback端口本身的掩码是多少位，在邻居的路由表中学习到的都是`/32`位路由，这是由于loopback端口类型导致的。如果希望loopback端口的路由呈现出其本身端口掩码的路由，修改其OSPF网络类型为Broadcast即可

P2P字面意思看起来容易与单播产生联系，但对于OSPF而言P2P只是一种网络类型的名称，它与单播没有任何联系；NBMA所对应的二层链路类型帧中继，基本已经被淘汰，NBMA网络类型现在只是适用于既需要建立OSPF邻居关系，又不能通过组播转发数据的场景

![hub-spoke模型](file:///${DB}/image/HCIP/hub-spoke%E6%A8%A1%E5%9E%8B.png)

hub-spoke模型可以用于需要对对流量进行策略的场景，总部作为hub可以访问到任意分支spoke，spoke之间通信的下一跳给到hub，在hub上可以实现对所有spoke之间的通信进行策略操作，例如集中监控

### OSPF基本配置命令

```yaml
ospf 1 router-id 4.4.4.4            //启用ospf进程1，并手动配置Router ID
 area 0.0.0.1                       //指定在Area 1内宣告网络
  network 1.1.45.0 0.0.0.255        //反掩码宣告网络
  network 1.1.45.0 255.255.255.0    //正掩码宣告网络；设备会自动纠正为反掩码配置
  network 10.1.4.4 0.0.0.0           //精确匹配端口IP的宣告方式
display ospf interface [s2/0/0] [verbose]    //查看设备上哪些端口在运行ospf进程
display ospf [process_id] peer [brief]    //查看ospf的邻居关系表
display ospf lsdb                   //查看LSDB的摘要信息

ospf 1 router 6.6.6.6               //修改设备Router ID
reset ospf 1 process                //用户视图下重启ospf进程
interface s2/0/0
 ospf timer hello 2                 //修改设备端口的hello timer
 ospf timer dead 10                 //修改设备端口的dead intervals
 ospf authentication-mode md5 1 cipher admin@huawei.com    //ospf端口设置认证
 ospf mtu-enable                    //端口开启MTU检测
 ospf network-type p2p              //修改设备端口的ospf网络类型
```

修改设备Router ID不会立即生效，必须重启ospf进程，重启OSPF进程意味着设备会删除LSDB、邻居关系等信息，都需要重新获取；OSPF的认证有2种设置方式，可以在端口视图配置认证信息、也可以在区域视图下配置认证信息