# 路由协议分类

```
                                                                             路由
                                                                              |
                                                ------------------------------------------------------------
                                                |                                                          |
                                             非直连路由                                                   直连路由
                                                |
                                   ----------------------------------------------------------
                                   |                                                        |
                              动态路由协议                                                 静态路由
                                   |
                      -------------------------------------------------------
                      |                                                     |             
                 内部网关协议IGP          <---（按AS区分）--->          外部网关协议EGP
                      |                                                     |
              ------------------------------                               BGP
              |                            |
距离矢量协议（Distance Vecter)      链路状态协议（Link-State）
              |                            |
          --------                      --------
          |      |                      |      |
         RIP   EIGRP                   OSPF  IS-IS
```

静态路由特点：

1. 简单、高效、稳定、开销小，适合小规模组网
2. 中大规模组网中配置量较大
3. 强依赖管理员的经验和技术水平，容易产生环路或次优路径
4. 无法自动适应拓扑变更

动态路由特点：

1. 需要额外占用设备、网络资源去建立、维护路由器之间的邻居关系和路由信息
2. 自动计算路由构建路由表，根据路由表执行数据转发
3. 自动适应拓扑变更

静态路由完全依赖管理员手动配置和维护，复杂的组网下使用静态路由容易产生环路或次优路由。静态路由配置简单、开销小，可以实现负载均衡和路由备份，适用于小规模组网场景，大规模组网中使用静态路由时配置和维护的成本都比较高，因此大规模组网中往往采用动、静态路由结合的方式部署

# OSPF基本概念

OSPF（Open Shortest Path First）开放式最短路径优先协议是IETF定义的一种基于链路状态的IGP协议，OSPF直接工作于网络层的IP协议中，IP协议号为89。这意味着OSPF只支持IP协议，这对于现在的网络环境而言也算不上什么缺陷

**OSPF概述**

- 大中型网络使用最广泛的基于链路状态的IGP协议
- 无类路由协议
- 使用组播224.0.0.5和224.0.0.6
- 使用开销（OSPF的Cost，根据接口带宽来计算）作为度量值，收敛速度快
- 采用SPF算法可以有效避免环路
- 触发式更新，一旦路由状态产生变化立即触发更新；OSPF也具备周期性的更新，以较低的频率（每30分钟）发送定期更新，被称为链路状态泛洪
- 区域的设计使OSPF能够支持更大规模的网络
- 通过LSA的形式发布路由
- 不支持自动汇总，支持手动汇总

OSPF存在3个版本，OSPFv1是早期的实验版本、OSPFv2基于IPv4、OSPFv3基于IPv6。OSPF协议使用SPF算法计算路由，最早期使用SPF算法的是IS-IS协议，但由于IS-IS基于OSI协议栈研发，因此IETF取IS-IS协议的SPF算法，基于TCP/IP协议栈开发了OSPF协议，IS-IS后续也推出了集成IS-IS，集成IS-IS即支持OSI协议栈也支持TCP/IP协议栈

**链路状态路由协议**

1. 路由器会将自身所有链路状态信息汇总泛洪到网络中
2. 收集其他路由器泛洪的链路信息，并写入自身链路状态数据库（LSDB）
3. 路由器根据SPF算法以自身为根节点计算最短路径树
4. 将通过SPF算法计算出的最短路径写入路由表

链路状态信息主要包含端口IP及掩码、链路带宽、链路上的邻居等信息，在OSPF协议中，LSA（Link-State Advertisement，链路状态通告）包含了链路状态信息，泛洪链路状态信息通过泛洪LSA实现，同时LSA也是LSDB的最小组成单位。SPF算法以自身为根节点，也就是说计算最短路径的时候会使用路由器自身去往目标网络的出接口的开销值；通信是一个双向的过程，对于本端路由器而言开销值最小的出接口可能是A链路，但对于对端路由器而言开销值最小的出接口也可能是B链路，因此OSPF路由器之间收发数据并不一定在同一条链路上，取决于两端路由器的SPF算法计算出的最短路径

**OSPF的3张表**

- Neighbor table：邻居表/邻接表；OSPF的邻居状态分为2种：邻居关系、邻接关系，邻接关系比邻居关系更深入一些，但对于这张Neighbor table而言无需区分的如此明显，既可以称为邻居表也可以称为邻接表
- Topology table：链路状态数据库表（LSDB）
- Routing table：路由表

相比较Distance Vecter，Link-State能够识别更多的路由信息。Distance Vecter只是传递路由表，每个路由器的状态类似道听途说；Link-State需要实现LSDB的同步，而LSDB中包含了整个网络中详细的链路状态信息，对整个网络的认知更加全面，因此Link-State倾向于做出更精确、更优的选路。每一个动态路由协议都会有自身的独立的数据库

## OSPF的区域设计

为了适应大型网络，OSPF能在AS内划分多个区域（Area），区域以设备端口为单位进行划分，一个设备端口只能属于一个区域，因此一台设备可以属于一个或多个区域，每台OSPF设备只维护所在区域的LSDB

**OSPF区域特征**

- 最小化LSDB
- 将拓扑变化的影响局限在一个区域内
- 明细LSA泛洪会停止在区域边界
- 分层化的网络规划设计

因为每台OSPF设备会维护所在区域的LSDB，如果所有OSPF设备处于同一区域，那么每台OSPF设备的LSDB会变得异常庞大，区域设计的优势在于减小了OSPF设备需要维护的LSDB规模，间接性减小了OSPF设备的路由表条目、内存、CPU消耗，同时区域的拓扑变化也仅影响本区域内部

```
              OSPF区域设计
                   |
   ---------------------------------
   |                               |
Area 0                         非Area 0
                                   |
                      ---------------------------
                      |                         |
                   常规区域                   特殊区域
                                                |
                                    -------------------------
                                    |       |       |       |
                                   Stub   T-Stub   NSSA   T-NSSA
```

- Area 0：骨干区域，也称为传输区域，负责在不同非骨干区域之间分发路由信息
- 非Area 0：非骨干区域，所有非骨干区域必须与骨干区域直接相连，这是为了防止区域间形成路由环路
  - 特殊区域：减少特殊区域的LSA通告；由于OSPF协议主要面对于企业网，而企业网的特点之一就是设备的性能参差不齐，将性能低下的设备集中放置在特殊区域中，减少对该区域的LSA通告数量

> **注意**
> 
> 任何两个非骨干区域之间的互相通信都必须经过Area 0，且只会经过Area 0一次

**OSPF路由器的分类**

OSPF路由器根据处于区域的不同位置分为了4种路由器类型；一台路由器也可以同时属于多种类型

- IR：Internal Router，内部路由器，所有的接口都属于同一区域
- BR：Backbone Router，骨干路由器，至少有一个接口属于骨干区域
- ABR：Area Border Router，区域边界路由器，连接一个或者多个区域到骨干区域，至少有一个接口属于骨干区域
- ASBR：Autonomous System Border Router，自治系统边界路由器，把从其他路由协议学习到的路由以引入的方式到OSPF进程中

**区域ID**

区域ID（Area ID）：可以表示成一个十进制的数字，例如1；也可以表示成一个IP，例如0.0.0.1。配置OSPF协议时，在OSPF协议下宣告网络之前必须指定一个Area ID

## OSPF的邻居类型

二层链路是以太网多路访问（MA）网络时，如果设备之间两两建立邻居关系，那么参与OSPF网络的接口数量越多，OSPF的邻居关系数量会呈倍数增长，复杂的邻居关系会占用路由器本身的性能与网络带宽。OSPF最终的目的是为了同步LSDB，而不是为了建立邻居关系，因此为了减少OSPF数据包的交换次数，产生了DR（Designated Router）与BDR（Backup Designated Router）的选举，DR和BDR的选举能够一定程度上减少邻居关系的数量

| 术语 | 备注 |
| :-: | :-- |
| DR | Designated Router，指定路由器，MA网络中的主路由器 |
| BDR | Backup Designated Router，备用DR，DR宕机时BDR顶替成为DR |
| DROthers | 无身份的路由器 |
| 三者关系 | DR、BDR、DROthers三者之间都保持邻接关系（Full）<br />DROthers之间保持邻居关系（Two-Way） |
| 组播地址 | 225.0.0.5 向所有OSPF路由器发送<br />224.0.0.6 向DR和BDR发送链路状态更新 |
| 选举规则 | 1、比较Hello报文中携带的优先级<br />2、优先级一致时比较RID，越大越优先 |

> **Router Priority（优先级）**
>
> 在OSPF网络中用于选举DR和BDR
> - 优先级范围0~255，默认是1
> - 优先级最高的被选举为DR，优先级次高的被选举为BDR
> - 优先级为0的不参与选举

DR和BDR的选举具有非抢占性，除非DR和BDR都失效或重启OSPF进程；DROthers感知到拓扑变更后会向组播地址224.0.0.6发送LSU，DR、BDR会监听224.0.0.6这一组播地址，收到DROthers的LSU后DR会向224.0.0.5这一组播地址发送更新以通知其他DROthers，所有的OSPF路由器都会监听224.0.0.5组播地址，都会收到DR泛洪的LSU

*二层链路是P2P网络时，运行OSPF协议建立邻居关系无需选举DR或BDR，P2P网络的OSPF设备就是两两之间建立邻居关系*；DR与BDR的选举根据不同二层网络类型产生变化，只有MA网络才会选举DR和BDR，但*ExStart状态下的主从关系是无论何种二层网络类型都必须选举的*；部分场景下也会刻意将OSPF接口的网络类型修改为P2P类型，这样可以加快OSPF的收敛速度，因为P2P不需要选举DR、BDR，例如确保两台设备的以太网接口直接互联，中间没有其他二层交换机时，就可以将OSPF端口手动修改为P2P类型

**LSDB的同步**

LSDB的同步本质上是LSA的更新，而LSA的更新规则重点关注其序列号和老化时间。LSDB中每条LSA都有自己的序列号，正常情况下序列号的值会随着时间的推移而递增

- 序列号：是一个4字节的数字，与IP地址一样长，以16进制显示。序列号的值从`0x80000001`开始、到`0x7FFFFFFF`结束，从`0x80000001`开始累加后最终会累加到全F，再加1就要进位了，但序列号没有进位，所以到全F再加1又会从0开始累加，直到0x7FFFFFFF
- 老化时间：OSPF每次LSA更新都会导致序列号的值累加1，包括触发更新和周期性更新（每30分钟泛洪一次LSA），序列号值越高代表该LSA越新
- LSA更新机制：当一条LSA序列号为`0x7FFFFFFF`时，始发路由器会将该LSA的老化时间设置为3600s，其他设备收到该LSA后，因为序列号最大会无条件接受该LSA，此时又因为老化时间参数会删除该LSA。此时始发路由器会重新生成并发送序列号为`0x80000001`的全新LSA信息，实现序列号的刷新机制，因此最终序列号的值还是会返回到`0x80000001`

> 扩展
>
> `0x`开头表示十六进制数，且该数值有符号（分正负），带符号的数值的第一位数字表示符号位，`0x80000001`的第一位8转变为二进制表示`1000`，第一位为1表示负数

**LSA的老化时间**

- LS Age单位是秒，随时间而增长，越小代表该LSA越新
- 一条LSA在向外泛洪之前，LS Age的值需要增加InfTransDelay，该值可以在端口上设置，缺省为1秒，表示在链路上传输的延迟
- 如果一条LSA的LS Age达到了LSRefreshTime（30分钟），重新生成该LSA。重新生成LSA意味着序列号会增加，同时LS Age归零重新开始计算
- 如果一条LSA的LS Age达到了MaxAge（1小时） ，这条LSA会被删除。正常情况下LS Age是不会达到MaxAge的，因为达到LSRefreshTime时就会重新生成LSA，但如果路由器希望从网络中删除一条自己此前生成的LSA，则重新生成该条LSA的一个实例，将LS Age设置为MaxAge即可
- 如果路由器收到一条LS Age设置为MaxAge的LSA，则从LSDB中删除此LSA

在配置命令中，undo一下某一条OSPF的宣告路由，从抓包信息中就能够看到LSU包内的LSA，LS Age时间设置为了3600s，表示删除此路由

**LSA的新旧关系**

1. 序列号值越高代表该LSA越新
2. 序列号相同的情况下，校验和越大的LSA越新；LSA报文的头部信息中包含有链路状态校验和字段
3. 序列号和校验和相同的情况下比较老化时间；老化时间为3600s的LSA被无条件选中，老化时间不为3600s时比较两条LSA的时间差值，如果差值大于15min则老化时间较小的更新，如果差值小于15min则认为两条LSA相同

![LSA的更新规则](file:///${DB}/image/HCIP/LSA%E7%9A%84%E6%9B%B4%E6%96%B0%E8%A7%84%E5%88%99.png)

1. OSPF路由器收到LSU包后首先会检索自身LSDB，判断LSU包内的LSA是否已存在自身LSDB中，如果不存在则在LSDB中添加新记录
2. 如果自身LSDB已存在该LSA，则会判断两者序列号是否相同，如果序列号相同则丢弃LSU中的LSA
3. 如果LSU包中的LSA序列号更高，则更新自身LSDB
4. 如果LSU包中的LSA序列号更低，则将自身LSDB中更新的LSA信息，通过LSU发送到源路由器

## OSPF的包类型

|                类型                 | 作用                                                         |
| :--------------------------------: | :----------------------------------------------------------- |
|               Hello                  | 建立并维护邻居关系；<br />1. 在OSPF刚刚启动的状态下，向外发送HELLO包寻找邻居；<br />2. 在邻居关系稳定后，每隔一段固定的时间向邻居发送HELLO，用来维持邻居关系<br />3. Hello间隔时间不同的ospf路由器之间无法建立邻居关系； |
|    Database Description（DBD）     | LSDB的摘要信息，仅包含LSA头部，用于路由器之间相互交换DBD获取对方LSDB中的LSA；<br />OSPF中不是通过交换路由表学习路由，是通过交换LSDB学习路由 |
|     Link-State Request（LSR）      | 请求LSA；<br />交换DBD报文收集双方LSDB中的差异后，请求对方LSDB中有而自身LSDB没有的LSA |
|      Link-State Update（LSU）      | 发送完整的LSA；<br />向邻居发送LSA |
| Link-State Acknowledgment（LSACK） | 对LSU报文的确认 |

在OSPF邻居建立完成后基本上就不会再产生DBD包和LSR包了，除非通过机制触发。如果某个路由器上的路由产生了新的变化，该路由器会主动向外发送LSU包，邻居路由器收到更新的LSA信息后也会给该路由器回复LSACK包，LSU包中更新的LSA会含有一个字段Sequence Number，这个字段就是序列号，用于标识LSA信息的新旧程度

**Router ID**

运行OSPF协议前必须选取一个Router ID，可以手动配置也可以自动生成，手动配置Router ID的情况下，Router ID的地址跟路由器上任何一个端口的IP地址都没有必然的联系。Router ID用于在自治系统中唯一标识一台OSPF路由器，且在同一OSPF区域中Router ID不能重复，Router ID以32位整数的方式呈现，类似IP地址。

Router ID的选举优先级：

1. 手动配置
2. 活动的环回端口上，选举最大的IP地址作为Router ID
3. 活动的物理端口上，选举最大的IP地址作为Router ID

Router ID的选举具有非抢占性，当设备上的Router ID已经选举完成后，即便后续产生了更大的端口IP、或手动修改Router ID，也需要重启OSPF进程才会生效，重启OSPF进程意味着设备会删除LSDB、邻居关系等信息，需要重新获取。Router ID为0.0.0.0时是特殊情况，Router ID为0时不能成为DR或BDR；当路由器没有自己的Router ID时，即便向外宣告OSPF网段也不会产生任何信息

**OSPF基本配置命令**

```VRP
ospf 1 router-id 4.4.4.4            //启用ospf进程1，并手动配置Router ID
 area 0.0.0.1                       //指定在Area 1内宣告网络
  network 1.1.45.0 0.0.0.255        //反掩码宣告网络
  network 1.1.45.0 255.255.255.0    //正掩码宣告网络；设备会自动纠正为反掩码配置
  network 4.4.4.4 0.0.0.0           //精确匹配端口IP的宣告方式
display ospf interface [s2/0/0] [verbose]    //查看设备上哪些端口在运行ospf进程
display ospf [process_id] peer [brief]    //查看ospf的邻居关系表
display ospf lsdb                   //查看LSDB的摘要信息
```

**路由的优先级和度量值**

路由协议的优先级用于比较一台设备上，通过不同的路由协议到达相同的目标网络的优先级，优先级的值越低，则路由协议越优先。例如设备RTA上能够同时通过RIP和OSPF到达目标网络1.1.1.0/24，此时根据路由协议的优先级比较，RTA会选择OSPF协议到达目标网络

路由的度量值用于比较一台设备上，通过同一路由协议到达同一目标网络的不同路径的优先级，优先级的值越低，则路径越优先。例如设备RTA通过OSPF协议学习到两条链路去往RTB，一条链路的Cost值为20、另一条链路Cost值为10，优先选择Cost值为10的链路到达目标网络；查看OSPF进程下的端口信息可以看到端口的开销值，每一个运行OSPF的端口上都维护着一个端口Cost，`Cost=10^8(bps)/BandWidth`

不同路由协议的优先级（Preference）是固定的，但Cost根据不同的协议有不同的算法，两者都可以调整

| 路由协议 | Direct | OSPF | IS-IS | Static | RIP | OSPF_ASE | OSPF_NSSA | IBGP | EBGP |
| :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
| 管理距离 | 0 | 10 | 15 | 60 | 100 | 150 | 150 | 255 | 255 |

## OSPF建立邻居的过程

