# BGP

在EGP协议中，引入了AS（Autonomous System，自治系统）的概念。AS是指由同一个技术管理机构管理，使用统一选路策略的一些路由器的集合。AS的内部使用IGP来计算和发现路由，如OSPF、ISIS、RIP等，同一个AS内部的路由器之间是相互信任的，因此IGP的路由计算和信息泛洪完全处于开放状态，人工干预很少。不同AS之间的连接需求推动了外部网关协议的发展，BGP作为一种外部网关协议，用于在AS之间进行路由控制和优选

BGP更关注于以一个AS作为一个节点，在不同的AS之间传递路由，而IGP关注的是将一个路由器的路由传递到其他路由器

**AS**

- 自治系统（AS）：单一技术管理下的一组网络
  - 16位编号（自2009年1月起使用32位编号）
  - 1 至 65535
  - 私有AS：64512-65534，65535保留

- 互联网编号指派机构（IANA，现在改名叫ICANN）会分配 AS 号
- IGP在AS内运行，AS间使用BGP

国内比较常见的AS号：中国电信163（4134）、中国电信CN2（4809）、中国网通（9929）；AS同时在BGP中还起到 *最佳路由的选择、避免环路、路由过滤* 等关键性作用

**BGP特点**

- 更新可靠：BGP在TCP 179端口上运行
- 仅增量式、触发式的更新
- 定期提供存活（keepalive）消息以验证TCP连接性，默认60s发送一次keepalive包，超过3个keepalive包没有回复时被认为非存活
- 丰富的度量标准，称作路径矢量或属性
- 专门为大型互联网络而设计

BGP是路径矢量协议，优于距离矢量协议。使用BGP的三大理由：

- 大量路由需要承载，IGP只能容纳千条路由，而BGP能够容纳上万路由
- 支撑MPLS/VPN应用，传递客户VPN路由
- 策略能力强，可以很好的实现路由决策与数据控制

依据这三个理由也可以反向理解，BGP能够容纳上万路由的前提也要求设备本身性能强大，在设备性能不够或工程师不具备足够强大的策略能力的情况下，不建议使用BGP

## BGP邻居

- BGP Speakers：运行BGP的路由器
- BGP Peers = BGP Neighbors = BGP对等体/邻居
- 邻居关系建立在 *TCP连接基础上* ，因此邻居 *不一定需要直连* ，可以通过 *IGP或静态* 路由来提供TCP连接的可达性。这个特性有别于IGP协议，以IGP的OSPF为例，OSPF通过组播或单播建立邻居，而它建立邻居的前提是两台路由器之间必须是三层网络上的直连
- BGP邻居 *必须手动* 指定，而非自动建立。区别于IGP协议，例如OSPF协议在组播网络下自动建立邻居
- 一台BGP路由器只能运行在 *一个AS内* （区别于其他IGP）

**BGP邻居类型**

| 类型 | 解析 |
| :-: | :-: |
| EBGP | 外部BGP邻居，位于不同AS |
| IBGP | 内部BGP邻居，位于相同AS |

**BGP邻居配置命令**

| 命令 | 作用 |
| :-: | :-: |
| bgp 123 | 声明所在AS号（创建进程） |
| router-id 1.1.1.1 | 配置RID，必须唯一；BGP下的router-id属于可选配置，不强制要求配置 |
| peer 12.0.0.2 as-number 123 | 配置邻居IP地址和邻居所在AS号 |
| display bgp peer | 查看BGP邻居状态 |

![BGP邻居信息](https://www.z4a.net/images/2023/10/31/BGP.png)

Established是BGP的最终状态，这个状态就表示邻居建立完成。BGP的邻居状态不会像OSPF一样在命令行展示过程，他只会展示最终状态

```Topology
<AR2>------------<AR1>-----------<AR3>
          AS12                    AS3
```

```VRP
#----------------------------------AR2----------------------------------
<Huawei>sys
[Huawei]sys AR2
[AR2]inte g0/0/0
[AR2-GigabitEthernet0/0/0]ip add 12.0.0.2 24
[AR2-GigabitEthernet0/0/0]bgp 12
[AR2-bgp]router-id 2.2.2.2
[AR2-bgp]peer 12.0.0.1 as-number 12

#----------------------------------AR1----------------------------------
<Huawei>sys
[Huawei]sys AR1
[AR1]inte g0/0/0
[AR1-GigabitEthernet0/0/0]ip add 12.0.0.1 24
[AR1-GigabitEthernet0/0/0]inte g0/0/1
[AR1-GigabitEthernet0/0/1]ip add 23.0.0.1 24
[AR1-GigabitEthernet0/0/1]bgp 12
[AR1-bgp]router-id 1.1.1.1
[AR1-bgp]peer 12.0.0.2 as-number 12
[AR1-bgp]peer 23.0.0.3 as-number 3

#----------------------------------AR3----------------------------------
<Huawei>sys
[Huawei]sys AR3
[AR3]inte g0/0/0
[AR3-GigabitEthernet0/0/0]ip add 23.0.0.3 24
[AR3-GigabitEthernet0/0/0]bgp 3
[AR3-bgp]router-id 3.3.3.3
[AR3-bgp]peer 23.0.0.1 as-number 12
```

**BGP邻居建立条件**

- 条件1：邻居地址可达
- 条件2：自身配置中的 *邻居所在AS号* = 邻居配置中的 *声明所在AS号*
- 条件3：数据包 *源IP* = 对方配置的 *邻居IP* ，这个源IP也叫更新源，也将作为路由的下一跳IP

在上面示例拓扑中用最简单的方式直接使用路由器的出接口IP作为邻居地址，但实际上邻居地址可以是路由器上任意一个接口的IP，包括环回口IP，但前提是路由器之间的IP能够正常通信，也就是目标IP在路由表中；条件3与路由器工作流程在一定程度上是对立的，数据包经过路由器发送出去时，源IP会修改为路由器出接口的IP。仍以上面拓扑为例，如果在配置BGP时将邻居IP修改为环回口的IP，数据包发送时源IP将被修改为路由器的出接口IP，不符合BGP邻居建立的条件3

在不符合条件3的情况下，无法建立TCP 3次握手，因为在3次握手过程中只能出现2个IP，而不满足条件3的情况下一定是BGP配置中指定的IP和实际数据包中的IP不匹配；**TCP 3次握手建立完成后才能开始AS的比对**

### 邻居优化

AR1与AR2属于IBGP，两者之间的通信可以直接通过IGP协议解决；AR1与AR3属于EBGP，只能通过静态路由指定去往AR3的路由

```VRP
#----------------------------------AR2----------------------------------
[AR2]inte loop 2
[AR2-LoopBack2]ip add 2.2.2.2 24
[AR2-LoopBack2]ospf 1 router-id 2.2.2.2
[AR2-ospf-1]area 0
[AR2-ospf-1-area-0.0.0.0]net 12.0.0.2 0.0.0.0
[AR2-ospf-1-area-0.0.0.0]net 2.2.2.2 0.0.0.0
[AR2-ospf-1-area-0.0.0.0]bgp 12
[AR2-bgp]undo peer 12.0.0.1
[AR2-bgp]peer 1.1.1.1 as-number 12

#----------------------------------AR1----------------------------------
[AR1]ip route-static 3.3.3.3 32 23.0.0.3
[AR1]inte loop 1
[AR1-LoopBack1]ip add 1.1.1.1 24
[AR1-LoopBack1]ospf 1 router-id 1.1.1.1
[AR1-ospf-1]area 0
[AR1-ospf-1-area-0.0.0.0]net 1.1.1.1 0.0.0.0
[AR1-ospf-1-area-0.0.0.0]net 12.0.0.1 0.0.0.0
[AR1-ospf-1-area-0.0.0.0]bgp 12
[AR1-bgp]undo peer 12.0.0.2
[AR1-bgp]undo peer 23.0.0.3
[AR1-bgp]peer 2.2.2.2 as-number 12
[AR1-bgp]peer 3.3.3.3 as-number 3

#----------------------------------AR3----------------------------------
[AR3]ip route-static 2.2.2.2 32 23.0.0.1
[AR3]inte loop 3
[AR3-LoopBack3]ip add 3.3.3.3 24
[AR3-LoopBack3]bgp 3
[AR3-bgp]undo peer 23.0.0.1
[AR3-bgp]peer 1.1.1.1 as-number 12
```

此时通过抓包可以看到各个路由器之间发起的TCP 3次握手都是失败的，可以看到TCP报文中的RST控制信号，此信号表示重置，且所有数据包的源IP都是对应路由器的出接口IP

**使用环回口建立BGP邻居**

使用环回口建立BGP邻居通常比物理口更加稳定

- 更新源：建立邻居和邻居所学习到的路由的下一跳

- 多跳：EBGP邻居建立默认需要直连，因为TTL=1，如果非直连，必须修改TTL

| 命令 | 作用 |
| :-: | :-: |
| peer 2.2.2.2 connect-interface lo 1 | 配置更新源 |
| peer 2.2.2.2 ebgp-max-hop [2] | 配置TTL，默认为1。配置此命令但未指定跳数的情况下，默认255跳 |

配置更新源实际上只需要在一端配置即可，基于TCP 3次握手的特性，配置更新源的终端向对端发起的3次握手不会被重置，一般建议在两端都配置命令，更加便于理解。在IBGP场景下使用非出接口作为邻居地址，仅需要配置更新源即可建立邻居

```VRP
#----------------------------------AR2----------------------------------
[AR2]bgp 12
[AR2-bgp]peer 1.1.1.1 connect-interface LoopBack 2

#----------------------------------AR1----------------------------------
[AR1]ip route-static 3.3.3.3 32 23.0.0.3
[AR1]bgp 12
[AR1-bgp]peer 2.2.2.2 connect-interface LoopBack1
[AR1-bgp]peer 3.3.3.3 connect-interface LoopBack1
```

基于多跳特性，AR1与AR3明显无法建立邻居，3.3.3.3不是AR3与AR1的直连端口，所以AR1的TCP请求虽然能到达AR3，但在AR3上会查找路由表，TTL值减1，路由器丢弃数据包。通过抓包能够看到AR1与AR3持续处于建立邻居，然后中断连接的循环

```VRP
#----------------------------------AR1----------------------------------
[AR1]bgp 12
[AR1-bgp]peer 3.3.3.3 ebgp-max-hop 2

#----------------------------------AR3----------------------------------
[AR3]bgp 3
[AR3-bgp]peer 1.1.1.1 connect-interface LoopBack 3
[AR3-bgp]peer 1.1.1.1 ebgp-max-hop 2
```

EBGP邻居之间一般建议采用直连接口建立邻居关系

**BGP身份验证**

| 命令 | 作用 |
| :-- | :-- |
| peer 2.2.2.2 password cipher 123 | 配置MD5加密的身份验证 |

BGP的身份验证会在所有包内启用，身份验证未设置正确，则TCP 3次握手都无法正常建立，TCP数据包内的Option字段会用于BGP的身份验证；如果在BGP邻居已经建立的状态下添加身份验证配置，keepalive包中会携带有身份验证信息的配置，BGP邻居状态也会产生变化，但BGP邻居变化的这个过程需要等待3倍keepalive包周期时间

## BGP报文结构和类型

*BGP的所有报文都是单播*

![BGP报文结构](https://www.z4a.net/images/2023/10/31/BGPbf2f0b3686c44882.png)

### BGP报文类型

| BGP报文类型 | 作用 |
| :-: | :-- |
| Open | 类似Hello，建立邻居关系；Open包只会在BGP建立邻居的初始状态发送一次 |
| Keepalive | 类似Hello，维护邻居关系 |
| Update | 路由更新，包含属性；Update包只有在BGP宣告路由时才会发送 |
| Notification | 当检测到错误或手动关闭BGP连接时，发送该数据包后关闭BGP连接 |
| Route-refresh | 当路由策略发生变化时，触发请求邻居重新通告路由 |

临时在AR2上宣告一条路由，通过抓包可以看到BGP的Update包

```VRP
[AR2]inte loop 3
[AR2-LoopBack3]ip add 172.16.2.2 32
[AR2-LoopBack3]bgp 12
[AR2-bgp]network 172.16.2.2 32	#BGP路由宣告
```

BGP有很多策略，一般情况下配置BGP和策略直接宣告使其生效即可，但BGP策略也会经常性的调整，而调整策略一般不会立即生效，此时可以通过命令触发策略的立即更新

```VRP
[AR2]acl 2000
[AR2-acl-basic-2000]rule 5 permit source 172.16.2.2 0
[AR2-acl-basic-2000]route-policy bgp permit node 10
[AR2-route-policy]if-match acl 2000
[AR2-route-policy]apply local-preference 200	#修改本地优先级，默认是100
[AR2-route-policy]bgp 12
[AR2-bgp]peer 1.1.1.1 route-policy bgp export
```

即便AR2通过路由策略修改了路由的local-preference字段，BGP也可能不会立刻向邻居发送Update包，在AR1上查看BGP的路由表可能会看到local-preference字段并未产生变化，通过refresh命令能实现BGP立即同步路由更新。refresh命令可以针对BGP的各种类型的邻居执行软重置，包括指定邻居、所有邻居、外部邻居等

```VRP
<AR2>refresh bgp all export		#软重置BGP的所有邻居的出站路由
<AR1>refresh bgp 2.2.2.2 import		#AR1请求AR2最新的路由更新
```

执行refresh命令时，如果由自身向外发送路由更新，也就是export出站，BGP会立刻向外发送Update包；如果由自身向邻居申请路由更新，也就是import入站，BGP会立刻向邻居发送Route-refresh包。import入站路由需谨慎，该命令可能会导致数以万计的路由引入自身设备，如果设备性能不足以支撑庞大的路由数量，可能会导致设备宕机

正常情况下，常见的BGP报文类型只有Open包和Keepalive包，没有路由更新的情况下不会产生Update包、没有重置BGP配置的情况下不会产生Notification包、没有请求路由更新的情况下不会产生Route-refresh包

### BGP状态类型

| BGP状态类型 | 描述 |
| :-: | :-- |
| Idle | 初始，路由器查找路由表，是否存在到达邻居的路由 |
| Connect | 发起TCP连接，等待TCP连接完成 |
| Active | TCP连接失败，继续尝试TCP连接 |
| Open Sent | TCP连接成功，已发送Open包，Open包中会比对AS |
| Open Confirm | 已收到对方正确的Open包，如果没有收到，会进入Active状态 |
| Established | 邻居建立完成，开始传递路由 |

**BGP正常建立邻居流程**

1. Idle：路由器必须要能够在路由表上查到去往邻居的路由，否则将一直保持Idle状态（BGP邻居建立条件1）
2. Connect：发起TCP 3次握手，此时必须保证两端之间3次握手的数据包的源IP匹配BGP配置（BGP邻居建立条件3）
3. Open Sent：TCP 3次握手完成后开始发送Open包，此时必须保证两端的Open数据包中记录的AS号与BGP配置中的邻居AS保持一致（BGP邻居建立条件2）
4. Open Confirm：比对完Open包确认正确后进入Open Confirm状态，然后向邻居发送Keepalive包
5. Established：收到Keepalive包后进入Established状态，邻居状态UP

![BGP邻居建立](https://www.z4a.net/images/2023/10/31/BGP07579233c9dde0eb.png)

**BGP状态机制**

![BGP状态机制](https://www.z4a.net/images/2023/10/31/BGP31f49ccb8c8252cf.png)

BGP的每一种状态类型的转换都具备严格的条件，成功、失败、超时都会具备相应的动作，在正常的BGP邻居建立过程中是不涉及Active状态的，需要特别注意Active状态的定义，TCP连接失败时会进入Active状态，TCP连接失败可能是由于数据包内的信息有误，例如源IP问题。Connect的超时是由于无法正常建立TCP连接超时，Active建立TCP连接超时时也会退回到Connect状态

一般BGP的邻居问题都会卡在Active状态，可能导致进入Active状态的原因：

- 不存在指向BGP数据包源IP地址的路由
- 邻居与错误的地址建立对等关系
- 不存在该路由器的邻居声明
- AS号配置错误

简而言之，导致Active状态的原因可以大概归类为3种可能性，某一边没有配置、某一边配置错误、两端配置不匹配

**BGP数据库**

| 类型 | 备注 |
| :-: | :-- |
| 邻居表 | BGP邻居名单 |
| BGP路由表（转发数据库；Loc-RIB） | 列出从邻居那里获取到的所有路由及属性 |
| IP路由表（IP-RIB） | 列出最佳路由 |
| Adj-RIB-In | 邻居宣告给本地的未处理的路由信息库 |
| Adj-RIB-Out | 本地宣告给指定邻居的路由信息库 |

**BGP路由信息处理过程**

![BGP路由信息处理过程](https://www.z4a.net/images/2023/11/03/BGP.png)

Adj-RIB-In和Adj-RIB-Out两个数据库不做详细讲解，在BGP路由信息处理过程中简单看作是两个不同阶段的缓存即可

## BGP路由宣告

**缺省情况下，BGP不发布任何本地路由**。BGP路由宣告原则如下

- 只有 *明确宣告* 的网络才会发送给邻居；必须手动执行命令宣告路由
- 宣告的网络必须能 *精确地* 在路由表中找到；宣告的路由必须在路由表中能够找到，这是前提，且宣告路由时IP前缀、掩码等信息都必须与路由表中的路由信息完全一致
- 多条路径时，只选 *最优* 路由给自身使用
- 只把自身使用的 *最优* 路由宣告给邻居
- 从EBGP学习到的路由会宣告给所有邻居
- *从IBGP学习到的路由不会宣告给IBGP* ；IBGP内的路由器路由宣告只传1跳（防环）
- 从IBGP学习到的路由会宣告给EBGP

路由宣告方式分两种：*本地宣告* 和 *引入宣告*

| 命令 | 作用 |
| :-- | :-- |
| display bgp routing-table | 查看BGP路由表 |
| network 192.168.0.0 255.255.255.0/24 | 宣告路由，精确匹配且存在路由表中；网络地址属于默认掩码时可以省略掩码 |
| import-route ospf/rip/static/connectc | 引入路由，通常结合路由策略 |
| default-route imported | 引入缺省路由，默认不允许 |
| peer 2.2.2.2 default-route-advertise | 向邻居宣告一条缺省路由，下一跳是自身IP，不论本地是否存在缺省路由，类似出口设备。这条路由宣告属于本地宣告 |

